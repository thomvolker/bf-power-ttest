<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Finding ellipsoidal probabilities under the multivariate normal model</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="mvn-probs_files/libs/clipboard/clipboard.min.js"></script>
<script src="mvn-probs_files/libs/quarto-html/quarto.js"></script>
<script src="mvn-probs_files/libs/quarto-html/popper.min.js"></script>
<script src="mvn-probs_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="mvn-probs_files/libs/quarto-html/anchor.min.js"></script>
<link href="mvn-probs_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="mvn-probs_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="mvn-probs_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="mvn-probs_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="mvn-probs_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Finding ellipsoidal probabilities under the multivariate normal model</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<div class="hidden">

</div>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Many statistical models impose multivariate normality, for example, for example on the regression parameters in a linear regression model. A question that may arise is how to find the probability that a random vector falls into some convex region <span class="math inline">\(\mathcal{A}\)</span> under this model. That is, we seek to find <span class="math display">\[
P(\mathbf{x}\in \mathcal{A}) = \int_{\mathcal{A}} f(\mathbf{x}) d\mathbf{x},
\]</span> where <span class="math inline">\(f(\mathbf{x})\)</span> is the density of the multivariate normal distribution. That is, <span class="math display">\[
f(\mathbf{x}) = \frac{1}{\sqrt{(2\pi)^p |\mathbf{\Sigma}|}}
\exp \Bigg\{
-\frac{1}{2} (\mathbf{x}- \mathbf{\mu})^\top \mathbf{\Sigma}^{-1} (\mathbf{x}- \mathbf{\mu}) \Bigg\},
\]</span> where <span class="math inline">\(p\)</span> denotes the number of dimensions, <span class="math inline">\(\mathbf{\mu}\)</span> is the mean vector, and <span class="math inline">\(\mathbf{\Sigma}\)</span> is the covariance matrix, and <span class="math inline">\(|\cdot|\)</span> denotes the determinant.</p>
</section>
<section id="solving-px-in-mathcala-when-mathcala-is-a-hyperrectangle" class="level1">
<h1>Solving <span class="math inline">\(P(x \in \mathcal{A})\)</span> when <span class="math inline">\(\mathcal{A}\)</span> is a hyperrectangle</h1>
<p>If the region <span class="math inline">\(\mathcal{A}\)</span> is rectangular, the problem is easily solved using of the shelf tools, such as the <code>pmvnorm</code> function in the <code>mvtnorm</code> package in <code>R</code>. In such circumstances, we seek to find the solution of the integral <span class="math display">\[
P(\mathbf{x}\in \mathcal{A}) =
\frac{1}{\sqrt{(2\pi)^p |\mathbf{\Sigma}|}}
\int_{a_1}^{b_1} \int_{a_2}^{b_2} \cdots \int_{a_p}^{b_p}
\exp \Bigg\{
-\frac{1}{2} (\mathbf{x}- \mathbf{\mu})^\top \mathbf{\Sigma}^{-1} (\mathbf{x}- \mathbf{\mu}) \Bigg\}
\Bigg\} d\mathbf{x},
\]</span> where <span class="math inline">\(a_i\)</span> and <span class="math inline">\(b_i\)</span> are the lower and upper bounds of the <span class="math inline">\(i\)</span>th dimension of the region <span class="math inline">\(\mathcal{A}\)</span>. <a href="https://www.jstor.org/stable/1390838">Genz (1992)</a> shows that this integral can be transformed into the iterated integral <span class="math display">\[
P(\mathbf{x}\in \mathcal{A}) =
(e_1 - d_1) \int_0^1 (e_2 - d_2) \dots \int_0^1 (e_m - d_m) \int_0^1 d \mathbf{w},
\]</span> with <span class="math inline">\(d_i = \mathbf{\Phi}((a_i - \sum^{i-1}_j c_{i,j} \mathbf{\Phi}^{-1}(d_j + w_j(e_j-d_j)))/c_{i,i})\)</span> and <span class="math inline">\(e_i = \mathbf{\Phi}((b_i - \sum^{i-1}_j c_{i,j} \mathbf{\Phi}^{-1}(d_j + w_j(e_j-d_j)))/c_{i,i})\)</span>. That is, we transform the problem into a series of univariate integrals that can be easily solved using standard univariate integration tools as, for example, <code>pnorm()</code> in <code>R</code>.</p>
<p>The following code implements the approach in <code>R</code>. Note, however, that the current implementations use some additional tricks to increase the accuracy of the program (or reduce the computation time), by changing the order of the variables.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>P <span class="ot">&lt;-</span> <span class="dv">5</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>rho <span class="ot">&lt;-</span> <span class="fl">0.5</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>S <span class="ot">&lt;-</span> rho <span class="sc">+</span> (<span class="dv">1</span><span class="sc">-</span>rho) <span class="sc">*</span> <span class="fu">diag</span>(P)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span>P</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Integration limits</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="sc">-</span>(<span class="dv">1</span><span class="sc">:</span>P)) <span class="sc">-</span> mu</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="dv">3</span> <span class="sc">*</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>P) <span class="sc">-</span> mu</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Test results</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>mvtnorm<span class="sc">::</span><span class="fu">pmvnorm</span>(<span class="at">lower =</span> a, <span class="at">upper =</span> b, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sigma =</span> S)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.8409671
attr(,"error")
[1] 1.364544e-05
attr(,"msg")
[1] "Normal Completion"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convergence limits</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>maxerr <span class="ot">&lt;-</span> <span class="fl">1e-4</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>Nmax <span class="ot">&lt;-</span> <span class="dv">10000</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Cholesky decomposition</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>C <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">chol</span>(S))</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize variables</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>intsum <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>varsum <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>N      <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>d1 <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(a[<span class="dv">1</span>]<span class="sc">/</span>C[<span class="dv">1</span>,<span class="dv">1</span>])</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>e1 <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(b[<span class="dv">1</span>]<span class="sc">/</span>C[<span class="dv">1</span>,<span class="dv">1</span>])</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>f1 <span class="ot">&lt;-</span> e1 <span class="sc">-</span> d1</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Loop until convergence</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>conv <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">numeric</span>(Nmax)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span>(<span class="sc">!</span>conv) {</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>  w <span class="ot">&lt;-</span> <span class="fu">runif</span>(P<span class="dv">-1</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>  di <span class="ot">&lt;-</span> d1</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  ei <span class="ot">&lt;-</span> e1</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  fi <span class="ot">&lt;-</span> ei <span class="sc">-</span> di</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>P) {</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i <span class="sc">==</span> <span class="dv">2</span>) yi <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    yi[i<span class="dv">-1</span>] <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(di <span class="sc">+</span> w[i<span class="dv">-1</span>] <span class="sc">*</span> (ei <span class="sc">-</span> di))</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    di <span class="ot">&lt;-</span> <span class="fu">pnorm</span>((a[i] <span class="sc">-</span> <span class="fu">sum</span>(C[i, <span class="dv">1</span><span class="sc">:</span>(i<span class="dv">-1</span>)]<span class="sc">*</span>yi))<span class="sc">/</span>C[i,i])</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    ei <span class="ot">&lt;-</span> <span class="fu">pnorm</span>((b[i] <span class="sc">-</span> <span class="fu">sum</span>(C[i, <span class="dv">1</span><span class="sc">:</span>(i<span class="dv">-1</span>)]<span class="sc">*</span>yi))<span class="sc">/</span>C[i,i])</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    fi <span class="ot">&lt;-</span> (ei <span class="sc">-</span> di) <span class="sc">*</span> fi</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>  intsum <span class="ot">&lt;-</span> intsum <span class="sc">+</span> fi</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>  varsum <span class="ot">&lt;-</span> varsum <span class="sc">+</span> fi<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>  N <span class="ot">&lt;-</span> N<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>  err <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">*</span> ((varsum<span class="sc">/</span>N <span class="sc">-</span> (intsum<span class="sc">/</span>N)<span class="sc">^</span><span class="dv">2</span>)<span class="sc">/</span>(N))<span class="sc">^</span>.<span class="dv">5</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>  out[N<span class="dv">-1</span>] <span class="ot">&lt;-</span> intsum<span class="sc">/</span>N</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (N <span class="sc">==</span> Nmax <span class="sc">|</span> err <span class="sc">&lt;</span> maxerr) conv <span class="ot">&lt;-</span> <span class="cn">TRUE</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>N</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 10000</code></pre>
</div>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>err</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.001287477</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>intsum<span class="sc">/</span>N</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.8424054</code></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(out[out <span class="sc">!=</span> <span class="dv">0</span>], <span class="at">type =</span> <span class="st">"l"</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">col =</span> <span class="st">"blue"</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h =</span> mvtnorm<span class="sc">::</span><span class="fu">pmvnorm</span>(<span class="at">lower =</span> a, <span class="at">upper =</span> b, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sigma =</span> S), <span class="at">lty=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mvn-probs_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Moreover, we can confirm the procedure using a small simulation.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> a <span class="sc">+</span> mu</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> b <span class="sc">+</span> mu</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">10000000</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N<span class="sc">*</span>P) <span class="sc">|&gt;</span> <span class="fu">matrix</span>(N) <span class="sc">%*%</span> <span class="fu">chol</span>(S) <span class="sc">+</span> <span class="fu">matrix</span>(mu, N, P, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span>P, <span class="cf">function</span>(p) X[,p] <span class="sc">&gt;=</span> a[p] <span class="sc">&amp;</span> X[,p] <span class="sc">&lt;=</span> b[p]) <span class="sc">|&gt;</span> </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a> {\(x) <span class="fu">rowSums</span>(x) <span class="sc">==</span> P}() <span class="sc">|&gt;</span> <span class="fu">mean</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.840875</code></pre>
</div>
</div>
<p>However, if the integration is not over a hyperrectangle, the current approach cannot be used, and we need to resolve to other techniques.</p>
</section>
<section id="solving-px-in-mathcala-when-mathcala-is-a-hyperellipse" class="level1">
<h1>Solving <span class="math inline">\(P(x \in \mathcal{A})\)</span> when <span class="math inline">\(\mathcal{A}\)</span> is a hyperellipse</h1>
<p>When the region <span class="math inline">\(\mathcal{A}\)</span> is an ellipse, the problem is more complicated, at least in the sense that it is not executable using the <code>mvtnorm</code> package.</p>
<section id="solving-px-in-mathcala-when-mathcala-is-a-constant-density-hyperellipse-around-mathbfmu" class="level2">
<h2 class="anchored" data-anchor-id="solving-px-in-mathcala-when-mathcala-is-a-constant-density-hyperellipse-around-mathbfmu">Solving <span class="math inline">\(P(x \in \mathcal{A})\)</span> when <span class="math inline">\(\mathcal{A}\)</span> is a constant-density hyperellipse around <span class="math inline">\(\mathbf{\mu}\)</span></h2>
<p>First, consider the case where the ellipse is a constant-density hyper-ellipse, that is by definition centered around the mean vector <span class="math inline">\(\mathbf{\mu}\)</span> and with axes in the directions of the eigenvectors of the covariance matrix <span class="math inline">\(\mathbf{\Sigma}\)</span>. We can visualize the idea as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>S  <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>), <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate a grid with density values for the multivariate normal distribution</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>x1 <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">2</span>, <span class="dv">4</span>, <span class="at">length.out =</span> <span class="dv">200</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>x2 <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">2</span>, <span class="dv">6</span>, <span class="at">length.out =</span> <span class="dv">200</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">expand_grid</span>(x1, x2) <span class="sc">|&gt;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">z =</span> mvtnorm<span class="sc">::</span><span class="fu">dmvnorm</span>(<span class="fu">cbind</span>(x1, x2), mu, S))</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Create evenly spaced points on a unit circle</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>angles <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">2</span><span class="sc">*</span>pi, <span class="at">length.out =</span> <span class="dv">50</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>unit.circle <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="fu">cos</span>(angles), <span class="fu">sin</span>(angles))</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify the radius of the circle</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>C <span class="ot">&lt;-</span> <span class="fl">2.5</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Make the circle elliptical by scaling with the Cholesky </span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co"># decomposition of the covariance matrix</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>ellipse <span class="ot">&lt;-</span> <span class="fu">t</span>(mu <span class="sc">+</span> <span class="fu">t</span>(unit.circle <span class="sc">%*%</span> <span class="fu">chol</span>(C <span class="sc">*</span> S)))</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_contour_filled</span>(<span class="fu">aes</span>(<span class="at">x =</span> X<span class="sc">$</span>x1, <span class="at">y =</span> X<span class="sc">$</span>x2, <span class="at">z =</span> X<span class="sc">$</span>z)) <span class="sc">+</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_path</span>(<span class="at">data =</span> <span class="cn">NULL</span>, </span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>            <span class="fu">aes</span>(<span class="at">x =</span> ellipse[,<span class="dv">1</span>], <span class="at">y =</span> ellipse[,<span class="dv">2</span>]),</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>            <span class="at">col =</span> <span class="st">"orange"</span>, <span class="at">linewidth =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mvn-probs_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Here, the orange circle in the plot represents the ellipse with constant density 0.046.</p>
<p>Noting that the quadratic form <span class="math inline">\(\Delta^2 = (X-\mathbf{\mu})^T\mathbf{\Sigma}^{-1}(X-\mathbf{\mu})\)</span>, which is also known as the Mahalanobis distance, follows a <span class="math inline">\(\chi^2_\nu\)</span> distribution with <span class="math inline">\(\nu = P\)</span> degrees of freedom, we can use this property to calculate the probability of a point falling within the ellipse.</p>
<p>Given that the radius of the ellipse is <span class="math inline">\(C\)</span>, we can calculate the probability that a point falls within the ellipse using the cumulative distribution function of the <span class="math inline">\(\chi^2\)</span> distribution, implemented in <code>R</code> as the <code>pchisq</code> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pchisq</span>(C, <span class="at">df =</span> <span class="fu">length</span>(mu))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.7134952</code></pre>
</div>
</div>
<p>We can verify this by simulating a large number of points, and calculating the proportion of the points that falls within the ellipse. Calculating whether a point falls within a given hyperellipse in a <span class="math inline">\(P\)</span>-dimensional space can be done by rotating the data points such that the axes of the ellipse align with the coordinate axes. Then, we can calculate whether the point falls within the ellipse by calculating the Euclidean distance of a point to the origin, and evaluate whether the sum of the squared coordinates is smaller than the squared half-axis-lengths. Note that the squared half axis lengths are given by the eigenvalues of the covariance matrix <span class="math inline">\(\mathbf{\Sigma}\)</span> multiplied with the constant <span class="math inline">\(C\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">100000000</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>P <span class="ot">&lt;-</span> <span class="fu">length</span>(mu)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N<span class="sc">*</span>P) <span class="sc">|&gt;</span> <span class="fu">matrix</span>(N) <span class="sc">%*%</span> <span class="fu">chol</span>(S) <span class="sc">+</span> <span class="fu">matrix</span>(mu, N, P, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>XC <span class="ot">&lt;-</span> X <span class="sc">-</span> <span class="fu">matrix</span>(mu, N, P, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>E <span class="ot">&lt;-</span> <span class="fu">eigen</span>(S)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>((XC <span class="sc">%*%</span> E<span class="sc">$</span>vectors)<span class="sc">^</span><span class="dv">2</span> <span class="sc">/</span> <span class="fu">matrix</span>(E<span class="sc">$</span>values <span class="sc">*</span> C, N, P, <span class="at">byrow =</span> <span class="cn">TRUE</span>)) <span class="sc">|&gt;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="fu">rowSums</span>() <span class="sc">|&gt;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>{\(x) x <span class="sc">&lt;=</span> <span class="dv">1</span>}() <span class="sc">|&gt;</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.7135046</code></pre>
</div>
</div>
<p>For a visual presentation of this procedure, consider the following example, in which we use the same parameters, but set the sample size to <span class="math inline">\(N = 100\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>Xs <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">100</span><span class="sc">*</span>P) <span class="sc">|&gt;</span> <span class="fu">matrix</span>(<span class="dv">100</span>) <span class="sc">%*%</span> <span class="fu">chol</span>(S) <span class="sc">+</span> <span class="fu">matrix</span>(mu, <span class="dv">100</span>, P, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>XCs <span class="ot">&lt;-</span> Xs <span class="sc">-</span> <span class="fu">matrix</span>(mu, <span class="dv">100</span>, P, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>angles <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">2</span><span class="sc">*</span>pi, <span class="at">length.out =</span> <span class="dv">50</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>unit.circle <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="fu">cos</span>(angles), <span class="fu">sin</span>(angles))</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>ellipse <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">t</span>(unit.circle <span class="sc">%*%</span> <span class="fu">chol</span>(C <span class="sc">*</span> <span class="fu">diag</span>(E<span class="sc">$</span>values))))</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>Xdist <span class="ot">&lt;-</span> ((XCs <span class="sc">%*%</span> E<span class="sc">$</span>vectors)<span class="sc">^</span><span class="dv">2</span> <span class="sc">/</span> <span class="fu">matrix</span>(C<span class="sc">*</span>E<span class="sc">$</span>values, <span class="dv">100</span>, P, <span class="at">byrow =</span> <span class="cn">TRUE</span>)) <span class="sc">|&gt;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rowSums</span>()</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Xs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mvn-probs_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(XCs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mvn-probs_files/figure-html/unnamed-chunk-7-2.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(XCs <span class="sc">%*%</span> E<span class="sc">$</span>vectors)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(ellipse, <span class="at">col =</span> <span class="st">"orange"</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(XCs[Xdist <span class="sc">&lt;=</span> <span class="dv">1</span>,] <span class="sc">%*%</span> E<span class="sc">$</span>vectors, <span class="at">col =</span> <span class="st">"blue"</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(XCs <span class="sc">%*%</span> E<span class="sc">$</span>vectors, <span class="at">labels =</span> <span class="fu">round</span>(Xdist, <span class="dv">2</span>), <span class="at">pos =</span> <span class="dv">2</span>, <span class="at">cex =</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mvn-probs_files/figure-html/unnamed-chunk-7-3.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Note that this approach is exactly equivalent to calculating the quadratic form explicitly, and calculating how many observations are smaller than the critical value <span class="math inline">\(C\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>Sinv <span class="ot">&lt;-</span> <span class="fu">solve</span>(S)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>delta <span class="ot">&lt;-</span> <span class="fu">rowSums</span>(XC <span class="sc">*</span> (XC <span class="sc">%*%</span> Sinv))</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(delta <span class="sc">&lt;=</span> C)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.7135046</code></pre>
</div>
</div>
<p>Using this approach, we can directly show that the quadratic form indeed follows a <span class="math inline">\(\chi^2_\nu\)</span> distribution.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>delta <span class="sc">|&gt;</span> <span class="fu">hist</span>(<span class="at">breaks =</span> <span class="dv">60</span>, <span class="at">freq =</span> <span class="cn">FALSE</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">curve</span>(<span class="fu">dchisq</span>(x, <span class="at">df =</span> P), <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">col =</span> <span class="st">"blue"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mvn-probs_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Now we have obtained a method to calculate the probability of a point falling within a hyperellipse centered around the mean vector <span class="math inline">\(\mathbf{\mu}\)</span> with axes in the directions of the covariance matrix <span class="math inline">\(\mathbf{\Sigma}\)</span>. However, when the ellipse is not centered around the mean vector, this approach will not work, and we need to resolve to a different method.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>